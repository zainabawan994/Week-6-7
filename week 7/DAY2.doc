The useEffect hook in React is commonly used to perform side effects such as making API calls. When you want to fetch data from an external API, you typically use useEffect so the call is triggered when the component is first rendered. The general flow is straightforward: when the component mounts, useEffect runs and executes the API call using fetch(). Since fetch() is asynchronous, it returns a promise that needs to be resolved, either by using .then() chaining or with async/await. Once the API responds with data, that data is usually converted into JSON format and then stored in a state variable using useState. Updating the state automatically re-renders the component, which allows you to display the fetched data in the UI.

It is also important to manage a loading state and an error state while working with API calls. Initially, you may set a loading variable to true, and while the API request is pending, you display a "Loading..." message to the user. Once the data is received, you set loading to false and render the actual data. Similarly, if the API call fails due to a network issue or an invalid URL, you can catch the error and store it in an error state, which can then be displayed to the user.

Another key part of useEffect is the dependency array. When you pass an empty array as the second argument, the effect runs only once, similar to componentDidMount in class components. If you include a variable in the dependency array, the effect will re-run every time that variable changes, which is useful when fetching data based on user input or route parameters.

In real-world applications, this pattern is used for many purposes such as fetching user profiles, product lists, weather data, or blog posts from APIs. By combining useEffect with useState, you can create dynamic and responsive components that fetch and render data efficiently.
